# lab1

## ·练习1

#### 1.la sp,bootstacktop

##### 1)操作：把bootstacktop的地址加载到寄存器sp（堆栈指针）中，

##### bootstacktop指向的是内核启动时使用的栈的顶部

##### 2）目的：初始化堆栈指针，为内核运行做好准备

#### 2.tail kern_init

##### 1)操作：直接跳转到kern_init函数，不保留返回地址（kern_init执行完后不会回到kern_entry）

##### 2)目的：将控制权转移到内核初始化函数，开始整个内核初始化的过程



## 扩展challenge1：描述与理解中断流程

#### 1.ucore中处理异常的流程：

kern/trap/trapentry.S

##### 1)保存上下文

A.把原先的栈指针sp保存到sscratch中

B.把sp向低地址延申36个寄存器的空间

C.依次保存31个通用寄存器（sp借助sscratch存）、4+1个控制寄存器的值存入内存（栈中）

##### 2）调用中断处理程序

A.先把sp的值传递给a0,作为函数参数传递给函数trap

##### 3）恢复上下文

A.把内存（栈）中存储的两个CSR（sstatus,sepc）,以及除了sp的31个寄存器的值存回寄存器

B.恢复sp值，把内存中存储的sp值赋给sp

##### 其中，mov a0,sp的目的是把sp的值作为函数参数，借由a0传递给函数trap.

`void trap(struct trapframe *tf) { trap_dispatch(tf); }`

观察trap函数，发现接收了一个函数参数，为指向trapframe(存储了上下文信息)的指针。

#### 2.SAVE_ALL中寄存器保存在栈中的位置是什么确定的？

由sp（sp的值向低地址延申了36个REGBYTES）,以及索引*REGBYTES的偏移量确定。

#### 3.对于任何中断，__alltraps 中都需要保存所有寄存器吗？

不需要，不过为了简化设计，不为特定的中断类型而选择性保存，保存所有寄存器是最简便安全的。

比如zero寄存器，无法被修改，其实不必被保存。

比如一些不可恢复的中断（比如除0操作），也没有必要保存全部寄存器信息。



## 扩展2：理解上下文切换机制

#### 1.在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？

##### 1）csrw sscratch, sp：把原本要存储的sp值暂存（写）进sscratch中

##### 2）csrrw s0, sscratch, x0：把sscratch中存放的原先sp值写入s0,同时把sscratch恢复成0.

##### 3）目的：把sp拷贝进另一个寄存器中，方便对sp进行修改（把sp减去36个寄存器空间大小），之后再进行恢复

#### 2.save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？

##### 1）诸如stval,scause等csr,提供了中断发生的原因等辅助信息，也指示了当前的中断状态；这些内容在中断结束后无需恢复，否则可能混淆已经结束中断的程序状态

##### 2）既然不用恢复，那为什么还要保存呢？在调用中断处理程序时，需要这些csr的内容辅助判断；如果中断处理程序运行期间被中断，也能恢复这些信息。



## ·基本知识

### 一、中断概念

#### 1.中断机制

##### 1）硬件发现异常、进行中断、交由软件处理

##### 2）一般OS中进行中断处理支持的方法

---前期工作---

A.编写相应的中断处理代码

B.在启动中正确设置控制寄存器

---异常-引发->中断---

C.CPU捕获异常

D.控制转交给相应中断处理代码处理

E.返回正在运行的程序

#### 

#### 2.中断分类

##### 1）异常（exception）:执行指令过程中发生了错误。

比如：访问无效内存地址、执行非法指令（除以零）、缺页等。有的可以恢复（缺页），有的不能恢复（除0）.

##### 2）陷入（trap）:主动通过一条指令停下来，并跳转到处理函数。

比如通过ecall进行系统调用（syscall），或者通过ebreak进入断点。

##### 3）外部中断（interrupt）:简称中断，即CPU的执行过程被外设发来的信号打断。

比如定时器倒计时结束，串口收到数据。

##### 外部中断是异步的。

Cpu不知道外部中断合适发生，无需等待，有了外部中断再处理。

*注：在riscv中，中断和异常统称“trap”



#### 3.riscv权限模式

##### 中断处理程序一般处于内核态.

##### 1）M-mode:发生所有异常控制权都会转交M模式的异常处理程序

##### 2）S-mode:M-mode的异常处理程序可以将异常重新导向成S-mode,或者选择性将中断和同步异常交由S-mode处理。



#### 4.控制状态寄存器（CSRs）

##### 1)sstatus寄存器（supervisor status registers）-禁止中断

二进制位SIE为0：S态运行程序时，禁用所有中断。（U态不行）

二进制位UIE为0：禁止用户态程序产生中断。

##### 2）stvec(supervisor trap vector base address registers)-把中断映射到中断处理程序

A.如果只有一个中断处理程序，那么可以直接让strvec指向那个中断处理程序的地址。

B.最低位的两个二进制位：

00->剩下高位存储的是唯一中断处理程序的地址

01->剩下高位存储的是中断向量表基址

*riscv要求地址四字节补齐，低位补两个0即可

##### 3）触发中断进入S态处理时，硬件自动设置下列寄存器，以把信息提供给中断处理程序

##### A.sepc:记录触发中断的指令地址

##### B.scause:记录中断发生的原因，以及是否是外部中断

##### C.stval:记录中断处理所需的辅助信息



#### 4.和中断相关的RISCV特权指令

##### 1）ecall: 

S态执行此指令。触发ecall-from-s-mode-exception,从而进入M态的中断处理流程

U态执行则触发ecall-from-u-mode-exception,从而进入S态的中断处理流程（常用于系统调用）

##### 2）ebreak:

触发一个断点中断，从而进入中断处理流程

##### 3）sret:

从S态中断返回到U态，pc<-sepc

##### 4）mret:

从M态中断返回到S态或U态，pc->mepc