#include <mmu.h>
#include <memlayout.h> 
   # 在入口点 entry.S 中所要做的事情是：
   # 将SP 寄存器从原先指向 OpenSBI 某处的栈空间，改为指向我们自己在内核的内存空间里分配的栈；同时需要跳转到函数 kern_init 中
   # OpenSBI 负责引导和初始化系统的基本硬件。在完成自身的引导工作后，OpenSBI 将控制权移交给操作系统的入口，即 entry.S。
   # 它可以理解为 OpenSBI 引导并启动了操作系统，但不会执行操作系统的代码。
   #entry.S 文件的作用是设置并启动 RISC-V 内核的虚拟内存机制，并最终跳转到内核初始化函数 kern_init。
   #它主要实现了从物理地址模式到虚拟内存模式的切换，并配置三级页表来支持虚拟地址映射。

   #总结一下，要进入虚拟内存访问方式，需要如下步骤：
   # 1. 分配页表所在内存空间并初始化页表；
   # 2. 设置好页基址寄存器（指向页表起始地址）；
   # 3. 刷新 TLB。

    .section .text,"ax",%progbits
    .globl kern_entry
kern_entry:
    # 1.设置三级页表的物理地址
    # t0 := 三级页表的虚拟地址
    lui     t0, %hi(boot_page_table_sv39)
    # t1 := 0xffffffff40000000 即虚实映射偏移量
    li      t1, 0xffffffffc0000000 - 0x80000000
    # t0 减去虚实映射偏移量 0xffffffff40000000，变为三级页表的物理地址
    sub     t0, t0, t1
    # t0 >>= 12，变为三级页表的物理页号
    srli    t0, t0, 12
    
    # 2.配置 satp 寄存器来启动虚拟内存
    # t1 := 8 << 60，设置 satp 的 MODE 字段为 Sv39
    li      t1, 8 << 60
    # 将刚才计算出的预设三级页表物理页号附加到 satp 中
    or      t0, t0, t1
    # 将算出的 t0(即新的MODE|页表基址物理页号) 覆盖到 satp 中
    # 将组合后的值写入 satp 寄存器，启用三级页表映射。
    csrw    satp, t0
    # 使用 sfence.vma 指令刷新 TLB,确保页表的更新生效。
    sfence.vma
    # 从此，我们给内核搭建出了一个完美的虚拟内存空间！
    #nop # 可能映射的位置有些bug。。插入一个nop
    
    # 3.设置栈指针并跳转到内核入口函数
    # 我们在虚拟内存空间中：随意将 sp 设置为虚拟地址！
    lui sp, %hi(bootstacktop)

    # 我们在虚拟内存空间中：随意跳转到虚拟地址！
    # 跳转到 kern_init
    lui t0, %hi(kern_init)
    addi t0, t0, %lo(kern_init)
    jr t0

.section .data
    # .align 2^12
    .align PGSHIFT
    .global bootstack
bootstack:
    .space KSTACKSIZE
    .global bootstacktop
bootstacktop:

.section .data
    # 由于我们要把这个页表放到一个页里面，因此必须 12 位对齐
    .align PGSHIFT
    .global boot_page_table_sv39
# 分配 4KiB 内存给预设的三级页表
boot_page_table_sv39:
    # 0xffffffff_c0000000 map to 0x80000000 (1G)
    # 前 511 个页表项均设置为 0 ，因此 V=0 ，意味着是空的(unmapped)
    .zero 8 * 511
    # 设置最后一个页表项，PPN=0x80000，标志位 VRWXAD 均为 1
    .quad (0x80000 << 10) | 0xcf # VRWXAD
