# lab3实验报告
## 重要知识点
### 一、交换区

如果交换区里没有找到需要的页面，不能直接去磁盘的其他位置寻找，这是因为磁盘上的数据和交换区的数据有明确的用途和分工，它们的逻辑和组织结构完全不同。

| **特性**                | **交换区**                                             | **磁盘的其他部分（如文件系统）**                           |
|-------------------------|-------------------------------------------------------|---------------------------------------------------------|
| **用途**               | 存放被换出的内存页面                                     | 存储文件、目录等用户数据                                 |
| **管理方式**           | 操作系统管理，使用交换条目记录虚拟页与交换区位置的映射关系 | 文件系统管理，通过文件路径访问                           |
| **访问方式**           | 通过交换条目访问，基于物理地址或偏移量                   | 通过文件系统接口访问，基于文件路径或文件描述符           |
| **数据结构**           | 顺序扇区存储，页面大小固定                               | 复杂数据结构（如索引节点、目录表）支持多种文件操作       |
| **性能优化**           | 为快速换入换出设计，通常连续存储                         | 为持久存储优化，支持随机读写和文件操作                   |

在标准操作系统中，找不到页面时，操作系统不会直接在磁盘中搜寻。换出的页面严格保存在交换区中，与文件系统数据分离。

## 练习二

### 1. 为何 `get_pte()` 函数中的两段代码如此相似？

`get_pte()` 函数分两步实现了对多级页表的逐级解析：

- 第一段代码解析最高一级页表（Giga 页表）。
- 第二段代码解析次一级页表（Mega 页表）。

两段代码形式相似的原因在于多级页表的解析逻辑是**递归的和分层的**。在 sv32、sv39 和 sv48 的页表机制中，页表结构由**层级化的索引机制**构成，每一层次的页表解析都遵循类似的规则：

#### 相同的逻辑流程：
1. 提取虚拟地址的一部分作为当前级别的页表索引（如 `PDX1` 和 `PDX0`）。
2. 查找或分配页表项。
3. 如果页表项无效，则需要分配内存并设置为有效。

sv32、sv39 和 sv48 的异同点：

1. sv32 是 RISC-V 的 32 位架构，采用两级页表结构。一级页表包含指向二级页表的指针，而二级页
表包含页表项。sv32 的页表项大小是 4 字节。

2. sv39 是 RISC-V 的 64 位架构，采用三级页表结构。一级页表包含指向二级页表的指针，二级页表
包含指向三级页表的指针，而三级页表包含页表项。sv39 的页表项大小是 8 字节。

3. sv48 也是 RISC-V 的 64 位架构，采用四级页表结构。类似于 sv39，它包含更多的页表级别，每个
级别都包含指向下一级页表的指针，最后一级包含页表项。sv48 的页表项大小也是 8 字节。


#### 原因总结：
- 页表解析的本质是通过虚拟地址逐级索引，最终定位到具体的物理页表项（PTE）。
- 每一层次的操作在逻辑上相同，具体实现只需切换到对应层的索引和数据结构即可。

---

### 2. `get_pte()` 函数是否需要将查找和分配功能拆分？

#### 当前实现的优点：
1. **简化代码结构**：
   - 将查找和分配合并在一个函数中，可以使代码更加紧凑，减少函数调用的层级，便于代码的维护和理解。
   
2. **性能优化**：
   - 查找和分配通常是紧密相关的操作，尤其是在页表项不存在时通常需要立即进行分配。将两者合并可以减少函数调用开销，避免重复遍历页表的逻辑，从而提升性能。

3. **一致性保障**：
   - 在一个函数中实现查找和分配，可以确保两个操作在逻辑上紧密配合，不会因不同函数的分离而导致不一致或错误的状态。

4. **避免代码冗余**：
   - 如果将查找和分配拆成两个函数，这两个函数可能会在实现中包含相似的逻辑（如页表项的地址计算、存在性检查等），会增加重复代码的可能性。而合并的方式能够减少代码重复，提高整体开发效率。

5. **适配本次实验的需求**：
   - 在实验中，分配页表项的操作仅在查找之后进行，且两者通常是结合在一起使用的。在这种情况下，分开实现并无明显的代码复用需求或性能提升。

---

#### 是否需要拆分？

**拆分查找和分配的适用场景：**
- 当需要单独检查页表项的存在性，而不涉及分配逻辑时，例如权限检查、页表状态验证等。
- 当查找和分配逻辑可能在不同场景中独立调用时，拆分有助于代码模块化和复用。

**本实验中的结论：**
- 当前 `get_pte()` 中，查找与分配紧密结合，且在不同地方独立调用的需求较少，因此没有必要将这两个功能拆分。合并实现既符合当前需求，也能减少代码的复杂性。


# 为什么 `3` 和 `1.2` 的代码不同，而 `1.2` 的代码却很相似？

### **原因：`1.2` 的代码为什么相似？**

`1.2` 的两段代码分别处理了 **Giga 页表** 和 **Mega 页表** 的解析和创建操作。两段代码的逻辑相似性来源于以下几点：

#### **1. 相同的核心逻辑：**
1. 根据虚拟地址的索引（`PDX1` 和 `PDX0`）找到对应的页表项。
2. 检查该页表项是否有效（即 `PTE_V` 标志是否置位）。
3. 如果无效，根据 `create` 参数决定是否分配新的页表。
4. 将新分配的页表清零，并更新页表项，设置权限和有效位。

#### **2. 页表解析的递归性质：**
多级页表是一种分层结构，每一级都需要解析并定位到下一层。Giga 页表和 Mega 页表的操作流程是相同的，只是解析的层次和数据结构不同。

#### **3. 差异仅在于索引：**
1. `PDX1(la)` 和 `PDX0(la)` 分别对应虚拟地址的高层和中间层索引。
2. 页表项的数据结构（页目录或页表）是从上一层逐级递归指向的。

因此，`1.2` 的代码几乎完全相同，这是多级页表机制设计中的共性体现。

---

### **为什么 `3` 的代码不同？**

`3` 的代码是整个递归的终点，负责返回最终的页表项（PTE）的指针，而不需要再递归解析或分配新的页表。

#### **1. 无需递归到更深层次：**
- **Giga 页表** 和 **Mega 页表** 的操作是为了找到下一层页表的入口（页表地址）。
- 到达 **最后一级页表** 时，已经定位到了具体的页表项（PTE），不需要再分配页表页。

#### **2. 返回页表项指针：**
`3` 的操作是直接从页表中提取页表项的指针，而不是为下一层页表分配新的内存。

#### **3. 最终目的是查找或创建 PTE：**
- `get_pte()` 的核心目的是返回 PTE 的地址，而不是继续向下解析。

---

### **总结**

- `1.2` 的代码相似，是因为多级页表的解析和创建逻辑在每一级都是递归且统一的。
- `3` 的代码不同，是因为它是整个递归的终点，不再需要向下解析，而是直接操作和返回页表项（PTE）。

## 练习四
### **1. 基本原理**
- **FIFO（First-In-First-Out）算法**：
  - 按页面进入内存的顺序进行替换。
  - 最先进入内存的页面最先被替换，无论该页面最近是否被访问过。
  - 实现简单，可用队列结构完成。

- **Clock算法**：
  - 是改进版的FIFO算法，利用“时钟指针”和页面的“访问位”来决定替换的页面。
  - 通过访问位判断页面是否被使用：
    - 如果访问位为1，则表示页面最近被访问，跳过并清零。
    - 如果访问位为0，则替换该页面。
  - 时钟指针不断循环移动，确保所有页面都能被检查。
  
- 总的来说，该算法近似地体现了 LRU 的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟
页替换算法在本质上与 FIFO 算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为 1 的页。