## 练习3
```
// 将addr对应的物理页数据从磁盘交换到物理内存中，假如内存已经满了，就会在过程中执行swap_out函数换出“不常用”的页来腾出空间
// 总之，最后由page存储最终得到的物理页面
swap_in(mm, addr, &page);

// 将交换进来的page页与mm->padir页表中对应addr的二级页表项建立映射关系（物理页--映射-->虚拟地址）
page_insert(mm->pgdir, page, addr, perm);

// 当前page是为可交换的，将其加入全局虚拟内存交换管理器的管理
swap_map_swappable(mm, addr, page, 1);

page->pra_vaddr = addr;
```

### 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
1. **页目录项（PDE）**:
   - **有效位（Valid bit）**: 该位指示页目录项是否有效。通过有效位，系统能够快速判断当前的页表是否存在，从而在进行页替换时有效地定位到相应的页表并处理相应的映射关系。
   - **页表物理地址（Page Table Address）**: PDE 中存储了指向页表的物理地址，这一信息可以帮助系统迅速找到对应页表的位置。因为在页替换过程中，我们需要频繁地访问页表以获取当前物理页的状态，PDE 的结构使得这一过程更加高效。
   - **权限位（Read/Write, User/Supervisor）**: 这些位用于控制对页面的访问权限，确保在进行页面替换时遵循安全策略，防止未授权访问。

2. **页表项（PTE）**:
   - **有效位（Valid bit）**: 类似于 PDE，PTE 的有效位用于指示该页表项是否有效，在进行页面替换时确保我们只处理有效的页面映射。
   - **脏位（Dirty bit）**: 此位用于指示页面是否被修改过。若要替换脏页，系统需要在替换之前将其内容写回到硬盘，以避免数据丢失。这个信息在消极换出策略中尤为重要，因为它决定了是否需要进行额外的数据写入操作。
   - **引用位（Accessed bit）**: 该位用于追踪页面的访问情况。在实现页面替换算法时，系统可以使用引用位来识别不常访问的页面，从而选择这些页面进行替换。
   - **交换位（Swap bit）**: 如果系统实施交换，PTE 中的交换位可以用于指示该页面是否在交换区中。这有助于系统管理哪些页面已经被替换到硬盘，哪些页面可以被重新加载。

页表替换的操作在ucore中采取了“消极换出策略”，也就是只有遇到没有空闲的物理页可供分配时，才会利用页替换算法把“不常用”的页从内存替换到硬盘上，然后从硬盘上加载出目标页。虽然我们在ucore中实际用vma和mm结构体管理虚拟内存，但虚拟内存到硬盘可用空间的映射是借助页目录项（PDE）和页表项（PTE）构建的树状结构完成的。在我们替换的过程中，这样的树状结构可以帮助我们迅速找到目标页在硬盘中的位置，从而实现更高效的页替换。

此外，PDE和PTE中的有效性、脏位和引用位等信息可以帮助我们更好地管理物理内存，选择那些不常用、未被修改的页面进行替换，从而提高内存的使用效率，在Clock和LRU替换算法中都有应用；而脏位可以决定在换出页面时是否需要写回磁盘。



### 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
trap--> trap_dispatch-->pgfault_handler-->do_pgfault
- CPU 保存当前寄存器状态到栈顶，并更新 scause 和 stval 寄存器，记录异常类型和出错地址。
- 根据`stvec`的地址跳转到中断处理程序，即`trap.c`文件中的`trap`函数。
- 跳转到`exception_handler`中，对 `CAUSE_LOAD_PAGE_FAULT` 和 `CAUSE_STORE_PAGE_FAULT` 两个case处理缺页异常。
- 在 `CAUSE_LOAD_PAGE_FAULT` 和 `CAUSE_STORE_PAGE_FAULT` 两个情况下，会跳转到`pgfault_handler()`函数，接着到`do_pgfault()`具体处理缺页异常。
- 在 `do_pgfault()` 中，会先执行 `swap_in()` 函数，这个函数会将物理页从磁盘交换到物理内存中，假如内存空间不够会间接调用 `swap_out()` 函数，借助页面置换算法把不常用的页踢出去； `page_insert()` 将交换进来的页与页表中对应地址的页表项建立映射关系。
- 如果处理成功，则返回到发生异常处继续执行；否则输出`unhandled page fault`。

### 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？
在 ucore 的内存管理中，Page 数据结构表示物理页面的管理信息。每一个 Page 实例通常是一个全局变量的数组，负责跟踪物理内存中的每一页。这些数据结构与页表（Page Table）中的页目录项（PDE）和页表项（PTE）之间存在直接的对应关系。

如果页表项映射到了物理地址，那么这个地址对应的就是`Page`中的一项。`Page` 结构体数组的每一项代表一个物理页面，并且可以通过页表项间接关联。页表项存储物理地址信息，这可以用来索引到对应的 `Page` 结构体，从而允许操作系统管理和跟踪物理内存的使用。

```
static inline struct Page *pte2page(pte_t pte) {
    if (!(pte & PTE_V)) {
        panic("pte2page called with invalid pte");
    }
    return pa2page(PTE_ADDR(pte));
}

static inline struct Page *pde2page(pde_t pde) {
    return pa2page(PDE_ADDR(pde));
}
```

```
#define PTE_ADDR(pte)   (((uintptr_t)(pte) & ~0x3FF) << (PTXSHIFT - PTE_PPN_SHIFT))
#define PDE_ADDR(pde)   PTE_ADDR(pde)
```

页表中的 PTE 存储的物理地址是 Page 数组对应物理页面的地址。通过pte2page()函数可以找到具体的 Page 结构。页目录项（PDE）也可能会指向存储页表的物理内存，间接与 Page 数组中的页面相关联。

## 练习5
- 如果我们采用 “一个大页” 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

好处：
- 代码简单，管理开销较低；
- 由于大页映射减少了页表项的数量，可能减少内存碎片和页表占用的内存；
- 地址转换只需一次查找，减少了多次查找的时间延迟，适用于具有高频访问的场景。

坏处：
- 我们看到各个段需要的访问权限是不同的。但是现在使用一个大大页(Giga Page)进行映射时，它们都拥有相同的权限，那么在现在的映射下，我们甚至可以修改内核 .text 段的代码，因为我们通过一个标志位 W=1 的页表项就可以完成映射，但这显然会带来安全隐患。大页的使用可能会影响不同进程之间的内存保护和隔离，增加了跨进程访问的风险。