### 练习二

ucore能做到给每个新fork的线程一个唯一的id。在这里通过get_pid分配id，它的原理是对于一个可能分配出去的last_id，遍历线程链表，判断是否有id与之相等的线程，如果有，则将last_id自增1，且保证自增之后不会与当前查询过的线程id冲突，并且其不会超过最大的线程数，重新从头开始遍历链表。如果没有，则更新下一个可能冲突的线程id。
通过这种算法，只有一个id在与所有线程链表中的id均不相同时才能分配出去，所以可以做到给每个新fork的线程一个唯一的id。

#### 1. last_pid 和 next_safe 的作用：

last_pid：是你当前正在尝试分配的进程编号，它从 1 开始递增。
next_safe：是系统当前已经分配的所有 PID 中的最大值加 1。它表示下一个未被分配的 PID，或者说是下一个“安全”的 PID。

### 2. 为何会发生 PID 重复的情况？
假设我们有 PID 从 1 到 100 的范围，系统中当前已经分配了一些 PID，比如 PID 1, 2, 5, 8，next_safe 应该是 9。意味着 PID 9 是下一个可以安全分配的编号。

如果此时 last_pid 已经是 8，那么下一个要分配的 PID 可能是 9（因为 last_pid 在不断递增）。
但如果 last_pid 增加到 9 以后，假设在这个过程中，系统的 PID 列表发生了变化，比如某个 PID 9 被其他进程占用了，last_pid 就会和已经占用的 PID 冲突。

### 3. 关键点：last_pid 大于 next_safe 时，说明有一个 PID 值被跳过了
如果 last_pid 比 next_safe 大（比如 last_pid = 10，而 next_safe = 9），意味着系统中存在一个 PID 已经被分配了，但它的编号比当前你要分配的 PID（last_pid）大。
这样，新的 last_pid 可能会和一个已经存在的 PID 发生冲突。因为，按照递增的规则，你会跳过一些编号，导致新分配的 PID 可能会与一个正在使用的 PID 重复。
### 4. 如何避免 PID 冲突？
当 last_pid 大于或等于 next_safe 时，程序就会检查当前系统中所有已经分配的 PID。这样做的目的是确保即使 last_pid 看起来可以分配，它仍然不会和其他进程的 PID 冲突。如果发生冲突，就会递增 last_pid 直到找到一个没有被占用的 PID。

我们定义PID最初的可用区间为[0,MAX_PID)，其中MAX_PID=2*MAX_PROCESS，即我们可用的PID数目是线程数的两倍，这保证了我们在使用的线程一定会有一个可用的PID。在该函数中我们定义了两个变量next_safe（可用PID区间右边界）和last_pid（可用PID区间左边界），即我们每次分配PID时都是在区间[last_pid,next_safe)中去依次递增，并且不断的调整该区间：

#### 详细讲解
- 当我们的变量last_pid增加到区间最右端点后，表示我们不能继续通过递增来获取pid，此时我们将该变量赋值为1，则我们现在将在区间[1,MAX_PID)之间遍历进程链表寻找可用pid
- 我们在遍历的过程中找到第一个与可用区间左端点相同的的pid，表示当前pid已被使用，然后判断last_pid+1是否超出区间右端点next_safe，如果超出则先判断是否与第一步类似，如果类似则做相同的处理，否则，将右端点移至最大值MAX_PID重复遍历过程；那么如果为超出右端点，则直接返回last_pid，此时这个变量存储的就是我们要分配的pid
- 我们现在已经解释了当我们找到第一个与可用区间左端点相同的的pid时的处理方式，那么我们在未找到该pid的时候该如何处理？判断当前pid是否在可用区间[last_pid,next_safe)内，如果当前pid在该区间内则更新右端点为当前pid
- 以上是我们在最初的时候的操作以及分配PID一轮之后的操作，那么其他时候将需要判断我们是否存在可用区间，即可用区间非空——左端点小于右端点，如果为空，则按照我们上面第二步和第三步重新寻找可用区间；否则，直接返回last_pid，此时这个变量存储的就是我们要分配的pid