## `copy_range` 函数实现概要

### 目标
将父进程的内存区域合法内容拷贝到子进程。

### 实现步骤
1. 在拷贝内存时，首先标记父进程和子进程的内存页为只读，并且指向同一物理页面。
2. 使用写时复制（COW）策略，只有当进程尝试修改这些页面时，才会进行实际的内存复制。此时，会为进程分配新的物理页面，并将原页面内容复制到新页面。

## Copy on Write 机制设计

### 1. 共享内存页
- 当父子进程共享某个内存页时，两个进程的页表项指向同一个物理页，并且将该页的访问权限设置为只读。

### 2. 写时拷贝
- 当任一进程尝试写入共享的内存页时，发生页面错误（page fault）。
- 操作系统捕获此错误，并检查该页是否已经被标记为只读。若是，只会为该进程分配一个新的物理页面，并将原内存页的内容复制到新页面。
- 更新页表，使得该进程的页表项指向新的物理页面，并将该页面的访问权限设置为可写。

### 3. 父子进程的页表管理
- 在 `do_fork` 中，父进程的页表需要被复制，子进程的页表可以共享父进程的内存页，直到写入时才进行复制。
- 对于每个内存页，设置页面保护属性为只读，并标记这些页面为 COW 页面。

### 4. 进程退出和内存释放
- 当进程退出时，检查其是否持有任何 COW 页面。如果是，需要释放这些页面的物理内存。

## 设计总结
这种设计能够有效地减少父子进程间的内存复制开销，尤其是在只读数据较多的情况下，提高内存的使用效率。

## 练习三

## 分析 `fork`、`exec`、`wait` 和 `exit` 函数的执行流程

### 1. **fork 执行流程**
- **用户态**：用户进程调用 `fork()`，请求内核创建一个子进程。
- **内核态**：
  - 内核为子进程分配一个新的进程描述符（进程控制块 PCB）。
  - 内核复制父进程的地址空间（通过页表复制，或采用 COW 策略）。
  - 内核为子进程设置唯一的进程ID。
  - 在父进程中，`fork` 返回子进程的 PID；在子进程中，`fork` 返回 0。
- **用户态**：根据 `fork` 返回值，父进程执行相应的代码，子进程开始执行新的代码。

### 2. **exec 执行流程**
- **用户态**：用户进程调用 `exec`，请求加载新的程序并替换当前进程的代码和数据。
- **内核态**：
  - 内核卸载当前进程的代码段、数据段、堆栈等资源。
  - 加载新的可执行程序（通过系统调用加载 ELF 文件等格式）。
  - 设置新的内存空间、堆栈和文件描述符等。
  - 进程从新加载的程序中开始执行。
- **用户态**：`exec` 返回后，进程开始执行新程序。

### 3. **wait 执行流程**
- **用户态**：父进程调用 `wait()`，请求等待子进程结束并获取其退出状态。
- **内核态**：
  - 内核检查子进程是否已经结束。
  - 如果子进程未结束，父进程会进入阻塞状态，等待子进程的退出。
  - 如果子进程已经退出，内核返回子进程的退出状态，并清理子进程的资源。
- **用户态**：`wait` 函数返回，父进程恢复执行并处理子进程的退出状态。

### 4. **exit 执行流程**
- **用户态**：进程调用 `exit()`，请求退出并释放资源。
- **内核态**：
  - 内核检查进程状态，清理进程的资源（如文件描述符、内存页、堆栈等）。
  - 如果是父进程等待子进程，则通过 `wait` 获取子进程的退出状态。
  - 进程从进程调度队列中移除。
- **用户态**：进程退出后，进程控制返回到操作系统的调度器。

## 用户态与内核态交替执行
- 用户程序通过系统调用（如 `fork`、`exec`、`wait` 和 `exit`）从用户态切换到内核态，内核完成任务后通过返回到用户态继续执行。
- 用户态发起系统调用，内核通过中断进入内核态。内核态处理完毕后通过返回指令回到用户态。
- 例如，`fork` 系统调用会在用户态发起，但需要在内核态完成进程创建，处理完后通过返回 PID 回到用户态。

## 用户态进程的执行状态生命周期图（字符方式）

```plaintext
+------------+    fork()    +------------+    exec()    +------------+
|   Running  | ------------>|   Ready    | ------------>|  Running   |
+------------+               +------------+               +------------+
     |                           |                           |
     |                           v                           |
     |                      wait() or exit()                 |
     |                           |                           |
     v                           v                           |
+------------+    exit()     +------------+    wait()     +------------+
|  Zombie    | <------------ |   Ready    | <------------ | Terminated |
+------------+               +------------+               +------------+

## 执行状态说明
1. **Running**：进程正在执行，处理器正在为该进程分配时间片。
2. **Ready**：进程已就绪，等待操作系统调度器分配 CPU 时间片。
3. **Zombie**：进程已终止，但父进程尚未调用 `wait()` 获取其退出状态，资源尚未完全清理。
4. **Terminated**：进程完全退出，资源已释放。

## 状态变换事件
- **`fork()`**：进程从 `Running` 状态进入 `Ready` 状态，父进程继续执行，子进程准备执行。
- **`exec()`**：进程从 `Ready` 状态变为 `Running`，但进程的地址空间被替换为新程序。
- **`wait()`**：父进程等待子进程的结束，若子进程已结束，则转变为 `Zombie` 状态，父进程获取其退出状态。
- **`exit()`**：进程从 `Running` 或 `Ready` 状态变为 `Zombie` 状态，直到父进程清理。
